import React, { createContext, useContext, useState, useEffect, useCallback, useMemo } from 'react';
import { StaffMember, StaffPermissions } from '../types';
import { supabase } from '../src/lib/supabase';
import { api } from '../src/lib/api'; // Import api helper

// Helper for localStorage
const STORAGE_KEY = 'shravya_auth_data';

const loadFromStorage = <T,>(key: string, fallback: T): T => {
    try {
        const saved = localStorage.getItem(key);
        return saved ? JSON.parse(saved) : fallback;
    } catch {
        return fallback;
    }
};

const saveToStorage = <T,>(key: string, data: T) => {
    try {
        localStorage.setItem(key, JSON.stringify(data));
    } catch (e) {
        console.warn('Failed to save to localStorage:', e);
    }
};

// Default permissions
const DEFAULT_PERMISSIONS: StaffPermissions = {
    dashboard: { view: true, manage: false },
    leads: { view: false, manage: false },
    customers: { view: false, manage: false },
    bookings: { view: false, manage: false },
    itinerary: { view: false, manage: false },
    inventory: { view: false, manage: false },
    masters: { view: false, manage: false },
    vendors: { view: false, manage: false },
    finance: { view: false, manage: false },
    marketing: { view: false, manage: false },
    staff: { view: false, manage: false },
    reports: { view: false, manage: false },
    audit: { view: false, manage: false },
};

const ADMIN_PERMISSIONS: StaffPermissions = {
    dashboard: { view: true, manage: true },
    leads: { view: true, manage: true },
    customers: { view: true, manage: true },
    bookings: { view: true, manage: true },
    itinerary: { view: true, manage: true },
    inventory: { view: true, manage: true },
    masters: { view: true, manage: true },
    vendors: { view: true, manage: true },
    finance: { view: true, manage: true },
    marketing: { view: true, manage: true },
    staff: { view: true, manage: true },
    reports: { view: true, manage: true },
    audit: { view: true, manage: true },
};

const INITIAL_STAFF: StaffMember[] = [];

interface AuthContextType {
    staff: StaffMember[];
    currentUser: StaffMember | null;
    isAuthenticated: boolean;
    isLoading: boolean;
    login: (email: string, password: string) => Promise<boolean>;
    logout: () => void;
    addStaff: (member: StaffMember, password?: string) => void;
    updateStaff: (id: number, member: Partial<StaffMember>) => void;
    deleteStaff: (id: number) => void;
    hasPermission: (module: keyof StaffPermissions, action: 'view' | 'manage') => boolean;
    masqueradeAs: (staffId: number) => void;
    stopMasquerading: () => void;
    isMasquerading: boolean;
    realUser: StaffMember | null;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
    const [staff, setStaff] = useState<StaffMember[]>([]);
    const [currentUser, setCurrentUser] = useState<StaffMember | null>(null);
    const [loading, setLoading] = useState(true);

    // Mock persistence key
    const STORAGE_KEY_MOCK = 'shravya_mock_session';

    // Mock Admin User Constant
    const MOCK_ADMIN_USER: StaffMember = {
        id: 999,
        name: 'Admin User',
        email: 'admin@shravyatours.com',
        role: 'Administrator',
        userType: 'Admin',
        initials: 'AD',
        department: 'Executive',
        status: 'Active',
        lastActive: new Date().toISOString(),
        color: 'indigo',
        queryScope: 'Show All Queries',
        whatsappScope: 'All Messages',
        permissions: ADMIN_PERMISSIONS,
    };



    // Unified User Loading Logic
    const loadUserProfile = useCallback(async (email: string) => {
        try {
            // 1. Try single fetch first
            const me = await api.getStaffByEmail(email);
            if (me) {
                setCurrentUser(me);
                // Background fetch full list
                api.getStaff().then(setStaff).catch(console.warn);
                return;
            }

            // 2. Fallback / Auto-create logic
            console.warn("User profile not found via direct fetch. Checking full list/creating.");
            const allStaff = await api.getStaff();
            const found = allStaff.find(s => s.email.toLowerCase() === email.toLowerCase());

            if (found) {
                setCurrentUser(found);
                setStaff(allStaff);
            } else {
                // Auto-create logic
                const isFirst = allStaff.length === 0;
                const isAdmin = email === 'toursshravya@gmail.com';

                const newStaffData: Partial<StaffMember> = {
                    name: email.split('@')[0],
                    email: email,
                    role: (isFirst || isAdmin) ? 'Administrator' : 'Agent',
                    userType: (isFirst || isAdmin) ? 'Admin' : 'Staff',
                    initials: email.substring(0, 2).toUpperCase(),
                    department: (isFirst || isAdmin) ? 'Executive' : 'Sales',
                    status: 'Active',
                    lastActive: new Date().toISOString(),
                    color: 'indigo',
                    queryScope: 'Show All Queries',
                    whatsappScope: 'All Messages',
                    permissions: (isFirst || isAdmin) ? ADMIN_PERMISSIONS : DEFAULT_PERMISSIONS
                };

                const created = await api.createStaff(newStaffData as any);
                setCurrentUser(created);
                setStaff([created, ...allStaff]);
            }
        } catch (e) {
            console.error("Error loading user profile", e);
        }
    }, []);

    // Consolidated Initialization
    const initializeAuth = useCallback(async () => {
        try {
            // 1. Check for Mock Session first (Fastest)
            const isMockSession = localStorage.getItem(STORAGE_KEY_MOCK) === 'true';

            if (isMockSession) {
                setCurrentUser(MOCK_ADMIN_USER);
                setStaff([MOCK_ADMIN_USER]);
                setLoading(false);
                return;
            }

            // 2. Check Supabase Session
            const { data: { session }, error: sessionError } = await supabase.auth.getSession();
            if (sessionError) throw sessionError;

            if (session?.user?.email) {
                await loadUserProfile(session.user.email);
            } else {
                setCurrentUser(null);
            }

        } catch (error) {
            console.error("Auth initialization failed", error);
            setCurrentUser(null);
        } finally {
            setLoading(false);
        }
    }, [loadUserProfile]);

    // Force safety timeout for loading state
    useEffect(() => {
        const safetyTimer = setTimeout(() => {
            setLoading(false);
        }, 10000); // 10s absolute max loading time
        return () => clearTimeout(safetyTimer);
    }, []);

    useEffect(() => {
        initializeAuth();

        // Listen for changes
        const {
            data: { subscription },
        } = supabase.auth.onAuthStateChange(async (event, session) => {
            // Only react to specific events to avoid infinite loops or double-fetching
            if (event === 'SIGNED_IN' || event === 'TOKEN_REFRESHED') {
                if (session?.user?.email) {
                    // Check if we already have this user loaded?
                    // Optimistic check:
                    if (currentUser?.email === session.user.email) return;
                    await loadUserProfile(session.user.email);
                }
            } else if (event === 'SIGNED_OUT') {
                setCurrentUser(null);
                setLoading(false);
                // Clear any mock data
                localStorage.removeItem(STORAGE_KEY_MOCK);
            }
        });

        return () => subscription.unsubscribe();
    }, [initializeAuth, currentUser, loadUserProfile]);

    const logAuthAction = useCallback(async (action: string, module: string, details: string, performedBy?: string) => {
        try {
            const user = performedBy || currentUser?.name || 'System';
            await api.createAuditLog({ action, module, details, severity: 'Info', performedBy: user, timestamp: new Date().toISOString() });
        } catch (e) {
            console.error('Failed to log auth action', e);
        }
    }, [currentUser]);

    const login = useCallback(async (email: string, password: string): Promise<boolean> => {
        // Dev/Demo Bypass
        if (email === 'admin@shravyatours.com' && password === 'admin') {
            localStorage.setItem(STORAGE_KEY_MOCK, 'true');
            // Ensure it's in the staff list
            setStaff(prev => {
                if (!prev.find(s => s.id === 999)) return [MOCK_ADMIN_USER, ...prev];
                return prev;
            });
            setCurrentUser(MOCK_ADMIN_USER);
            logAuthAction('Login', 'Authentication', `User ${email} logged in (Demo Mode)`, MOCK_ADMIN_USER.name).catch(console.error);
            return true;
        }

        try {
            const { data, error } = await supabase.auth.signInWithPassword({ email, password });
            if (error) {
                console.error('Login failed:', error.message);
                return false;
            }

            if (data.session?.user?.email) {
                await loadUserProfile(data.session.user.email);
                logAuthAction('Login', 'Authentication', `User ${data.session.user.email} logged in`, data.session.user.email).catch(console.error);
            }
            return true;
        } catch (e) {
            console.error("Login exception:", e);
            return false;
        }
    }, [loadUserProfile, logAuthAction]);

    const logout = useCallback(async () => {
        const userEmail = currentUser?.email || 'Unknown User';
        localStorage.removeItem(STORAGE_KEY_MOCK);
        await supabase.auth.signOut();
        setCurrentUser(null);
        logAuthAction('Logout', 'Authentication', `User ${userEmail} logged out`, userEmail).catch(console.error);
    }, [currentUser, logAuthAction]);

    const addStaff = useCallback(async (member: StaffMember, password?: string) => {
        try {
            const created = await api.createStaff(member, password);
            setStaff(prev => [created, ...prev]);
            logAuthAction('Create', 'Staff', `Added new staff member: ${member.name}`).catch(console.error);
        } catch (e) {
            console.error(e);
            throw e;
        }
    }, [logAuthAction]);

    const updateStaff = useCallback(async (id: number, member: Partial<StaffMember>) => {
        try {
            await api.updateStaff(id, member);
            setStaff(prev => prev.map(s => s.id === id ? { ...s, ...member } : s));
            logAuthAction('Update', 'Staff', `Updated staff member: ${member.name || `ID ${id}`}`).catch(console.error);
        } catch (e) {
            console.error(e);
            throw e;
        }
    }, [logAuthAction]);

    const deleteStaff = useCallback(async (id: number) => {
        try {
            await api.deleteStaff(id);
            setStaff(prev => prev.filter(s => s.id !== id));
            logAuthAction('Delete', 'Staff', `Deleted staff member ID: ${id}`).catch(console.error);
        } catch (e) {
            console.error(e);
            throw e;
        }
    }, [logAuthAction]);

    // Masquerade Logic (Client-side mainly)
    const [realUser, setRealUser] = useState<StaffMember | null>(null);

    const masqueradeAs = useCallback((staffId: number) => {
        const target = staff.find(s => s.id === staffId);
        if (target) {
            if (!realUser) setRealUser(currentUser);
            setCurrentUser(target);
        }
    }, [currentUser, staff, realUser]);

    const stopMasquerading = useCallback(() => {
        if (realUser) {
            setCurrentUser(realUser);
            setRealUser(null);
        }
    }, [realUser]);

    const hasPermission = useCallback(
        (module: keyof StaffPermissions, action: 'view' | 'manage'): boolean => {
            if (!currentUser) return false;
            if (currentUser.userType === 'Admin') return true;
            return currentUser.permissions?.[module]?.[action] ?? false;
        },
        [currentUser]
    );

    const value = useMemo(
        () => ({
            staff,
            currentUser,
            isAuthenticated: !!currentUser,
            isLoading: loading,
            login,
            logout,
            addStaff,
            updateStaff,
            deleteStaff,
            hasPermission,
            masqueradeAs,
            stopMasquerading,
            isMasquerading: !!realUser,
            realUser,
        }),
        [staff, currentUser, loading, login, logout, addStaff, updateStaff, deleteStaff, hasPermission, masqueradeAs, stopMasquerading, realUser]
    );

    return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

export const useAuth = () => {
    const context = useContext(AuthContext);
    if (!context) throw new Error('useAuth must be used within an AuthProvider');
    return context;
};

export { DEFAULT_PERMISSIONS, ADMIN_PERMISSIONS };
